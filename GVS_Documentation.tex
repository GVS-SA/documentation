% !TeX spellcheck = de_CH
\documentclass[11pt,a4paper,english,oneside]{book}

\usepackage{etex} %Because of many packages --> Extended TeX.
\usepackage[left=1in, right=1in]{geometry} %Helps to structure the paper layout.
\usepackage[Lenny]{fncychap} %Design of the thesis.
\usepackage[utf8]{inputenc} %Due to vowels.
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel} %Define the language style.

% german language for appendix header
\addto\captionsngerman{\let\appendixtocname\appendixname%
	\let\appendixpagename\appendixname}

% Setup glossary and acronyms
\usepackage[acronym,toc,nopostdot]{glossaries}
\loadglsentries{glossar-terms}
\glsenablehyper
\makeglossaries

% Include external pdf
\usepackage{pdfpages}

% set single pages to landscape
\usepackage{lscape}

\usepackage{dsfont} %Nice style for the indicator function.
\usepackage{fancyhdr} %To customize the headers and footers.
\usepackage{booktabs} %In case you need \cmidrule or \addlinespace in tables.
\usepackage[hang,bottom,stable,multiple]{footmisc} %Style of footnotes.
\usepackage{appendix} %For the \appendixpage command.
%Load some mathematical packages.
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[
backend=biber,
style=numeric,
sortlocale=de_CH,
natbib=true,
doi=true,
eprint=false
]{biblatex}  % Bibliography
\addbibresource{References.bib}
\usepackage{etoolbox} %To remove the page number on \appendixpage.
\usepackage{amsthm} %For theorems, definitions etc.
\usepackage{thmtools} %For theorems, definitions etc.
\usepackage{setspace} %Use double spacing.
\usepackage{lipsum} %For the \lipsum command to generate a text.
\usepackage{datetime} %For the specification of the date.
%\usepackage{tocloft} %The ToC, LoF and LoT each appear not necessarily on a new page.
\usepackage{graphicx,listings,xcolor,textcomp} %For the graphics, listings etc.
\usepackage{mcode} %To implement a Matlab code.
\usepackage[margin=10pt, font=small, labelfont=bf, labelsep=endash]{caption} %Customize the captions.
\usepackage{chngcntr} %To use counterwithout.
\usepackage{epstopdf} %For inserting .eps files into the document.
\usepackage{hyperref} %Must be loaded at the end.
\usepackage{xparse} %Load for \NewDocumentCommand command.
\usepackage{cleveref} %For the command \cref, load after hyperref.
\usepackage{arydshln} %Due to the capability to draw horizontal/vertical dash-lines.
\usepackage{array,hhline} %To create tables and matrices.
\usepackage{rotating} %To rotate a table.
\usepackage{tabularx} %An extended version of tabular.
\renewcommand{\arraystretch}{1.25}




%Setup of the reference links.
\hypersetup{
	colorlinks=true,
	linkcolor=cyan,
	anchorcolor=black,
	citecolor=cyan,
	filecolor=cyan,
	urlcolor=cyan,
	runcolor=cyan,
	menucolor=black
}


%Define some reasonable margins.
\setlength{\textwidth}{6.6in}
\setlength{\textheight}{8.8in}
\setlength{\topmargin}{-0.1in}
\setlength{\oddsidemargin}{0in}
\setlength{\parskip}{1mm}


\allowdisplaybreaks[1] %Page breaks of equations are allowed, but avoided if possible. 2-4 more relaxed.

%New command for the HSR logo.
\newcommand*{\plogo}{\includegraphics{logo_hsr.pdf}}

%New command for the differential d to have an ordinary d.
\makeatletter
\newcommand{\ud}{\mathrm{d}}
\makeatother

%Remove page number on \appendixpage. Use the package 'etoolbox'.
\makeatletter
\patchcmd{\@chap@pppage}{\thispagestyle{plain}}{\thispagestyle{empty}}{}{}
\makeatother

%Declare Definitions, Theorems etc.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\declaretheorem[style=definition,qed=$\blacktriangleleft$, numberwithin=chapter]{remark} %additional options; numberwithin=,..., see 'Thmtools' Users’ Guide
\declaretheorem[style=definition,qed=$\triangle$,numberwithin=chapter]{definition}
\newtheorem{ass}{Assumption}[chapter]
\newtheorem{prop}{Proposition}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\declaretheorem[style=definition,qed=$\perp$,numberwithin=chapter]{example}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{coroll}{Corollary}[chapter]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Readjust the numbering.
\counterwithout{footnote}{chapter}
\numberwithin{equation}{chapter}


%\setlength{\parindent}{0cm} %Uncomment this if you don't want to have indents.

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------
\newcommand*{\titleGP}{\begingroup %Create the command for including the title page in the document.
	\centering %Center all text.
	\vspace*{\baselineskip} %White space at the top of the page.
	\plogo\\[2\baselineskip] %University Logo.
	\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt} %Thick horizontal line.
	\rule{\textwidth}{0.4pt}\\[\baselineskip] %Thin horizontal line.
	{\LARGE Graphs-Visualization-Service GVS 2.0 }\\[0.2\baselineskip] %Title.
	\rule{\textwidth}{0.4pt}\vspace*{-\baselineskip}\vspace{3.2pt} %Thin horizontal line.
	\rule{\textwidth}{1.6pt}\\[2\baselineskip] %Thick horizontal line.
	\scshape %Small caps.
	\large Studienarbeit \\[2\baselineskip]
	Abteilung Informatik \par
	Hochschule für Technik Rapperswil
	\vspace*{2\baselineskip}
	
	
	Autoren\\
	{\Large  Michael Wieland  \\ [5pt]}
	
	{\Large Murièle Trentini \\ [5pt]}
	
	\vspace*{2\baselineskip}
	Betreuer\\
	{\Large Thomas Letsch  \\[5pt]
		\small Dozent für Informatik an der \\[5pt]Hochschule für Technik Rapperswil\par}
	\vspace*{2\baselineskip}
	
	\vfill
	{\scshape Zeitraum: 18.09.2017 - 22.12.2017} \\[0.3\baselineskip]
	\endgroup}


%Special header and footer style for the executive summary and Task Assignment section.
\fancypagestyle{firststyle}{%
	\fancyhf{}%
	\renewcommand{\headrulewidth}{0pt}
	\fancyfoot[L]{GVS 2.0}
	\fancyfoot[R]{\thepage}}

% customize header and footer for chapter pages
\fancypagestyle{plain}{
	\fancyhf{}
	\fancyfoot[L]{GVS 2.0}
	\fancyfoot[R]{\thepage}
	\renewcommand{\headrulewidth}{0pt}% Line at the header invisible
	\renewcommand{\footrulewidth}{0pt}% Line at the footer visible
}

%Customize headers and footers for normal pages
\pagestyle{fancy}
\fancyhead[R]{Murièle Trentini | Michael Wieland}
\fancyhead[L]{\rightmark}
\fancyfoot[L]{GVS 2.0}
\fancyfoot[C]{}
\fancyfoot[R]{\thepage}

%Define the signature line with dots.
\NewDocumentCommand \dotbox {o O{.5\linewidth} m O{3ex} O{\linewidth}}
{
	\begin{minipage}{7cm}
		\makebox[7cm][l]{\,.\dotfill}
		\\
		\makebox[7cm][l]{\,#3}
	\end{minipage}
}

\begin{document}
	\thispagestyle{empty}
	\titleGP
	\newpage
	\doublespacing
	\setcounter{page}{1}
	\pagenumbering{Roman}
	\section*{Abstract}
	\thispagestyle{firststyle}
	
	
	\newpage
	
	\section*{Management Summary}
	\thispagestyle{firststyle}
	
	\subsection*{Ausgangslage}
	
	\subsection*{Vorgehen, Technologien}
	
	\subsection*{Ergebnisse}
	
	\subsection*{Ausblick}
	
	\newpage
	
	\section*{Danksagungen}
	\thispagestyle{firststyle}
	
	Wir danken folgenden Personen für Ihre Unterstützung während der Studienarbeit:
	
	\begin{itemize}
		\item Thomas Letsch für die Betreuung unserer Studienarbeit.
		\item Jessica Martin für die technische Unterstützung beim Logo Design.
	\end{itemize}
	

	{
		\hypersetup{linkcolor=black}
		\tableofcontents
	}

	%TODO REMEMBER: Keine Verhangenheiten. Wir beschreiben was gemacht werden muss und nicht was gemacht wurde.
	
	%TODO Handbuch und Installationsanleitung. Kürzel in Fusszeile. Somit gibt es keine Verwirrung mit den Seitenzahlen
	
	\newpage
	\pagenumbering{arabic}
	% \part{[ Part title ]}
	\chapter{Anforderungsspezifikation}
	
	%TODO Enthält Anforderungen des Kuden/Auftrageber
	
	\begin{table}[h!]
		\centering
		\begin{tabularx}{\linewidth}{l l X l}
			\toprule 
			Datum & Version & Änderungen & Autor \\
			\midrule
			28.09.17 & 1.0 & Grundgerüst erstellt & mwieland \\
			17.10.17 & 1.1 & Sequenzdiagramme eingefügt & mtrentini \\
			18.10.17 & 1.2 & Ausgangslage und Stakeholder eingefügt & mwieland \\
			19.10.17 & 1.3 & Erkenntnisse: Stärken, Schwächen, Schlüsse beschrieben & mwieland \\
			\bottomrule 
		\end{tabularx} 
		\caption{Versionshistory Anforderungsanalyse} 
	\end{table}
	
	\section{Ausgangslage \& Problembeschreibung}
	An der \gls{hsr} werden in den Modulen ''Algorithmen und Datenstrukturen 1'' und ''Algorithmen und Datenstrukturen 2'' die Funktionsweise von schwierig zu verstehenden Algorithmen unterrichtet. Zusätzlicher Bestandteil der Module ist das Erlernen der beiden Datenstrukturen ''Graph'' und ''Tree''. Die Implementierung derartiger Algorithmen und Datenstrukturen ist oft mit grossem Aufwand verbunden. \\
	Die Software \gls{gvs} unterstützt Studenten beim Erlernen der beiden Datenstrukturen, sowie der darauf anwendbaren Algorithmen. Damit sich die Studenten ausschliesslich auf das Erlernen der Algorithmen fokussieren können, bietet \gls{gvs} eine Library, welche repetitive Implementierungsarbeiten den Studenten abnimmt. Der wichtigste Aspekt ist jedoch die Visualisierung der Arbeitsweise von Datenstrukturen und Algorithmen. So zeigt die Software zum Beispiel den schrittweisen Aufbau eines Baumes oder den Ablauf des Path Finding Algorithmus ''Dijkstra''. \\
	Die Software wurde 2005 bereits im Rahmen einer Bachelorarbeit umgesetzt. Der in die Jahre gekommene GVS 1.0 soll nun in einem Major-Upgrade aktualisiert werden.
	
	\subsection{Mehrwert}
	\gls{gvs} wird im Rahmen dieser Studienarbeit auf den neusten Stand der Technik gebracht und profitiert von neueren Java Features wie Generics und Lambdas sowie einer erweiterbaren Schichtenarchitektur. 
	Für den Endbenutzer ändert sich nur das User Interface. Dieses bekommt ein modernes und ansprechendes Design.

	
	\section{Anforderungen} \label{sec:functionalreq}
	Die Anforderungen werden massgeblich aus der offiziellen Aufgabenstellung entnommen. (siehe Anhang \ref{aufgabenstellung})
	
	\subsection{Funktionale Anforderungen}
	Die funktionalen Anforderungen werden vollständig von GVS 1.0 \cite{gvs1} übernommen. Der Funktionsumfang der Applikation soll nicht verändert werden.
	
	\subsection{Nicht funktionale Anforderungen}
	
	\begin{enumerate}
		\item In der \gls{gvsui} Komponente muss das Framework Swing durch \gls{javafx} ersetzt werden.
		\item In der \gls{gvslib} Komponente muss die Java und .NET Library um Generics erweitert werden. 
		\item Punktuell müssen Verbesserungen vorgenommen werden.
	\end{enumerate}

	Eine genaue Definition der dritten Anforderung ist im Abschnitt Refactoring Ablauf (\ref{ssec:ablauf}) beschrieben.
	
	\section{Domainanalyse}
	In der Domainanalyse wird der GVS 1.0 untersucht. Die Erkenntnisse fliessen in die Designspezifikation ein.
		
	\subsection{Stakeholder}
	Stakeholder repräsentieren Personen, die ein Interesse an der vorliegenden Software haben. Aus den funktionalen Anforderungen (\ref{sec:functionalreq}) von GVS 1.0 können drei relevant Stakeholder ermittelt werden. Während der Realisierung wird überprüft, ob die Erwartungen der Stakeholder erfüllt werden können. Wegen der technischen Orientierung der vorliegenden Studienarbeit werden speziell die Ansprüche zukünftiger Entwickler berücksichtigt.
	
	\begin{table}[h!]
		\centering
		\begin{tabularx}{\linewidth}{l l X X}
			\toprule 
			\# & Rolle & Ziel/Intention & Erwartungshaltung \\
			\midrule
			1 & Student & Möchte GVS unkompliziert installieren und benutzen können. (Unter Zuhilfenahme der Installationsanleitung) & Möchte den zu visualisierenden Graphen/Tree ansprechend dargestellt bekommen. Ihm ist der Lerneffekt wichtig.  \\
			2 & Entwickler & Möchte GVS einfach erweitern können. & Sucht nach bekannten Software Pattern und klaren Software Schichten. Erwartet eine informative Architekturdokumentation. \\			
			3 & Dozent & Möchte GVS in seinem Unterricht einsetzen. & Erwartet eine intuitive Integration von GVS in bestehende Übungsaufgaben. \\
			\bottomrule 
		\end{tabularx} 
		\caption{Relevante Stakeholder} 
	\end{table}

	\subsection{Aktoren} \label{ssec:actors}
	Aktoren sind externe Einflussfaktoren die mit dem System interagieren. Im GVS 1.0 gibt es zwei Aktoren.
	
	\subsubsection{GVS User} \label{sssec:actor-user}
	Der GVS User interagiert mit dem \gls{gvsui} über das User Interface. Er kann die aktuelle Visualisierungs-Session per Knopfdruck auf das Filesystem speichern oder eine bestehende Session von dort laden. Wenn ein Graph visualisiert ist, kann er die Koordinaten der Vertices neu berechnen lassen.
	
	\subsubsection{GVS Lib} \label{sssec:actor-lib}
	Die \gls{gvslib} Komponente wird in das Software Projekt des GVS User (\ref{sssec:actor-user}) eingebunden. Sie sendet in \gls{xml} beschriebene Datenstrukturen über eine Socket Verbindung an das \gls{gvsui}. Die Daten werden vom \gls{gvsui} auf dem Access Layer empfangen und auf dem User Interface visualisiert.
	
	\subsection{Systemübersicht}
	Die Systemübersicht zeigt schematisch wie die beiden Aktoren (Siehe \ref{ssec:actors}) mit dem  die \gls{gvsui} interagieren.
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.5\linewidth]{assets/images/system_overview}
		\caption{Systemübersicht GVS}
		\label{fig:gvs-systemuebersicht}
	\end{figure}
	
	\subsection{Klassendiagramm} \label{ssec:klassendiagramm-1}
	Das Klassendiagramm zeigt die wichtigsten Klassen von GVS 1.0. Im vorhergehenden Projekt wurden die Schichten zwar angedacht, sie widerspiegeln sich aber kaum im Package Design. Um den Überblick zu verbessern, sind die Klassen in diesem Diagramm den entsprechenden Schichten zugewiesen. Dies erhöht die Verständlichkeit der Problemdomäne und vereinfacht den Übergang in die neue Schichtenarchitektur von GVS 2.0. Eine genaue Analyse der GVS 1.0 Klassen ist dem Abschnitt \ref{sec:erkenntnisse} zu entnehmen. 
	
	\includepdf[fitpaper]{assets/pdf/gvs1-0.pdf}
		
	\subsection{Sequenzdiagramme}
	Um schwierig zu verstehende Systemabläufe zu abstrahieren, werden Systemdiagramme erstellt. Sie zeigen die wichtigsten Abläufe in GVS 1.0.
	
	\subsubsection{Verbindungsaufbau}
	Dieses Sequenzdiagramm zeigt den Verbindungsaufbau über den \textit{SocketServer} beim starten der Applikation. Der Start einer \textit{SeverConnectionXML} führt zu einem Locking mit Hilfe des \textit{ConnectionMonitors}. Dieses Locking verhindert, dass mehr als eine \gls{gvslib} gleichzeitig mit einem \gls{gvsui} kommuniziert. Nach dem Empfangen der Daten aus dem Socket, erstellt der \textit{ModelBuilder} einen Graphen oder Tree als Domain-Objekt. Dieser Ablauf ist auf dem Sequenzdiagramm \textbf{ModelBuilder} (siehe \ref{sssec:modelbuilder}) ersichtlich.
	\begin{figure}[h!]
		\centering
		\includegraphics[width=\linewidth]{assets/images/verbindungsaufbau}
		\caption{Sequenzdiagramm: Verbindungsaufbau}
		\label{fig:sd-verbindungsaufbau}
	\end{figure}

	\subsubsection{ModelBuilder} 	\label{sssec:modelbuilder}
	Der \textit{ModelBuilder} parsed aus den empfangenen \gls{xml} Dokumenten das entsprechende Domain-Objekt. Dabei wird zwischen Graphen und Trees unterschieden. Nach Fertigstellung des Parse-Vorgangs, wird das Model an den entsprechenden \textit{SessionController} übergeben. Der weitere Ablauf befindet sich im separaten Sequenzdiagramm \textbf{GraphSessionController} (siehe \ref{sssec:sessioncontroller})
	\begin{figure}[h!]
		\centering
		\includegraphics[width=\linewidth]{assets/images/modelbuilder}
		\caption{Sequenzdiagramm: ModelBuilder}
		\label{fig:sd-modelbuilder}
	\end{figure}

	\subsubsection{ApplicationView: Load \& Save Session} \label{sssec:appView}
	Wenn ein User eine Session lädt, wird das entsprechende \gls{xml} vom \textit{Persistor} geparsed. Dieser erstellt je nach Bedarf einen Vector aus Graphs oder Trees. Dieser Vector wird an den \textit{SessionController} übergeben. Der Ablauf innerhalb des \textit{SessionController}s ist im separaten Sequenzdiagramm \textbf{GraphSessionController} (siehe \ref{sssec:sessioncontroller}) dargestellt. \\
	Nachdem die Session erstellt wurde, wird die \textit{ApplicationView} per Observer-Beziehung (siehe Glossar: \gls{observer}) notifiziert. Sie stellt darauf die neue Session im \gls{gvsui} dar.\\
	Auffällig an der Klasse \textit{ApplicationView} ist, dass sie im Constructor einen \textit{Persistor} instanziert. Diese Instanz wird jedoch nicht direkt in der ApplicationView verwendet, sondern wird als Argument an den \textit{ApplicationController} geschickt, welcher dann mit dem Persistor Sessions speichert und lädt. In der Analyse des Projektteams ist unklar geblieben, wieso die Instanzierung des \textit{Persistor}s nicht direkt im \textit{ApplicationController} passiert.
	\begin{figure}[h!]
		\centering
		\includegraphics[width=\linewidth]{assets/images/application_view}
		\caption{Sequenzdiagramm: ApplicationView}
		\label{fig:sd-applicationview}
	\end{figure}

	\subsubsection{GraphSessionController} \label{sssec:sessioncontroller}
	Der \textit{GraphSessionController} wird vom \textit{ModelBuilder} und vom \textit{Persistor} angestossen, wenn ein oder mehrere neue Graphen geparsed wurden. Der \textit{GraphSessionController} ist dafür zuständig diese Graphen in eine neue oder bestehende Session einzufügen. Dabei unterscheidet sich der Programmablauf kaum. Der besseren Übersicht halber ist nur der Fall ''ein einzelner neuer Graph wurde empfangen'' abgebildet.\\
	Für Graphen die keine fix positionierte Vertices haben, wird in einem weiteren Schritt der \textit{LayoutController} aufgerufen. Dieser steuert die Funktionalität der Physics-Engine. Die Physics-Engine berechnet die Koordinaten von Vertices mittels anziehenden und abstossenden Kräften. (siehe \gls{forcedirecteddrawing}) Der \textit{GraphSessionController} wird  per Observer-Beziehung (siehe Glossar: \gls{observer}) informiert, sobald die Physics-Engine die Berechnung der Positionen abgeschlossen hat.\\
	Der \textit{GraphSessionController} setzt den neuen Graphen als aktuellen Graphen auf dem \textit{VisualizationGraphModel}. Dieses informiert per Observer-Beziehung (siehe Glossar: \gls{observer}) das \textit{VisualiztionGraphPanel}, welches die für die Darstellung benötigten Vertex und Edge Komponenten erstellt.
	\begin{figure}[h!]
		\centering
		\includegraphics[width=\linewidth]{assets/images/graph_session_controller}
		\caption{Sequenzdiagramm: GraphSessionController}
		\label{fig:sd-graphsessioncontroller}
	\end{figure}
	
	\subsection{Erkenntnisse} \label{sec:erkenntnisse}
	Die aus der Analysephase gewonnen Erkenntnisse fliessen in die Designspezifikation ein.
		
	\subsubsection{Layering}
	Dem Projektplan GVS 1.0 \cite{gvs1} kann eine Schichtenarchitektur bestehend aus zwei Schichten entnommen werden. Die Schichten widerspiegeln sich aber nicht im Package Design. Gut erkennbar ist das Server Interface, dass die Visualisierung vom Socket Server trennt. GUI spezifische Elemente ziehen sich durch mehrere Layer.
	
	\subsubsection{Swing/AWT Imports im Business Layer} 
	Im Business Layer gibt es diverse Imports der UI Frameworks \gls{swing} rsp. \gls{awt}. Dies erschwert einen Austausch des eingesetzten UI Frameworks.
	
	\subsubsection{Tangles} Zwischen dem Presentation und Business Layer existieren \gls{tangle}s. Dies verhindert einen einfachen Austausch des Presentation Layers. 
	
	\subsubsection{Magic Numbers} Viele Konstanten sind ungenügend beschrieben. Der Zweck von vielen Zahlen ist daher nur schwer nachvollziehbar.
	
	\subsubsection{Namenskonvention}
	Es gibt keine durchgehende Namenskonvention. Den Variablen fehlt es oft an Informationsgehalt. Ebenfalls sind veränderbare Variablen in Grossbuchstaben geschrieben, was per Konvention \cite{jls-naming} den Konstanten vorbehalten ist.
	
	\subsubsection{Temporary Fields}
	Viele Klassen arbeiten exzessiv mit Klassenvariablen, die in diversen Methoden gesetzt und gelesen werden. Des Weiteren werden die Klassenvariablen von Funktionsparameter und lokalen Variablen überdeckt.   
	
	\subsubsection{Duplicated Code}
	Klassen wie der \textit{ModelBuilder} und \textit{Persistor} übernehmen sehr ähnliche Aufgaben.
	
	\subsubsection{Long Classes}
	Einige Klassen überschreiten die Obergrenze von 250 Zeilen Code/Klasse. Dies hebt den Verdacht, dass die Klassen mehr als eine Aufgabe erledigen und somit das ''Single Responsibility Principle'' verletzen.
	
	\subsubsection{Keine Unit Tests} Im GVS 1.0 wurden keine Unit Tests geschrieben. Die Klassen sind sehr schwer testbar, da kein \gls{di} umgesetzt wurde.
	
	\subsubsection{JavaDoc}
	Das Verhalten von Klassen ist nicht durchgehend dokumentiert.  Ebenfalls fehlt es bei einigen Kommentaren an Aussagekraft.	

		
	\chapter{Designspezifikation}
	
	\begin{table}[h!]
		\centering
		\begin{tabularx}{\linewidth}{l l X l}
			\toprule 
			Datum & Version & Änderungen & Autor \\
			\midrule
			13.10.17 & 1.0 & MVVM Konzept geschrieben & mwieland \\
			19.10.17 & 1.1 & Refactoring Konzept erstellt & mtrentini \\
			20.10.17 & 1.1 & Klassendiagramm 2.0 & mtrentini, mwieland \\
			\bottomrule 
		\end{tabularx} 
		\caption{Versionshistory Designspezifikation} 
	\end{table}
	
	\section{Klassendiagramm} \label{sec:class-diagram}
	Das Klassendiagramm von GVS 2.0 orientiert sich stark an der Vorgängerversion des GVS 1.0. (Siehe \ref{ssec:klassendiagramm-1}). Mit dem Ziel möglichst viel Code wiederzuverwenden, wird der Access und Business Layer mehrheitlich beibehalten. Der Presentation Layer wird vollständig durch die neu eingeführte \gls{mvvm} Struktur ersetzt. (Siehe \ref{sssec:mvvm})
	
	\includepdf[fitpaper]{assets/pdf/gvs2-1.pdf}
	
	\section{Schichtenstruktur} \label{ssec:layer-architecture}
	
	\subsection{Presentation Layer}
	Der Presentation Layer wird von der restlichen Anwendung entkoppelt. Damit kann das eingesetzte UI Framework (z.B \gls{javafx}) leicht ersetzt werden. Der Presentation Layer ist nach dem \gls{mvvm} Prinzip organisiert.
	
	\subsubsection{Model-View-ViewModel} \label{sssec:mvvm}
	\gls{mvvm} dient der Trennung zwischen dem User Interface und der Anzeigelogik. \gls{mvvm} ist eine Konkretisierung des verbreiteten \gls{mvc} Pattern und setzt stark auf Databindings. Es wurde von Microsoft für das \gls{wpf} Framework entwickelt und wird auch in modernen \gls{javafx} Applikation eingesetzt.
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\linewidth]{assets/images/mvvm_concept}
		\caption[MVVM Konzept]{Übersicht Mode View ViewModel}
		\label{fig:mvvmconcept}
	\end{figure}
	
	\paragraph{Model}
	Das \textit{Model} enthält reine Datenklassen ohne nennenswerte Logik. (siehe \gls{pojo}) Das \textit{Model} wird in den Business Layer verschoben, damit das UI Framework einfach ausgewechselt werden kann. Werden die Werte im Model geändert, wird das \textit{ViewModel} über eine Observer Beziehung (\gls{observer}) benachrichtigt. Dies entspricht nicht dem klassischen \gls{mvvm} Konzept, wird jedoch benötigt, damit die View entsprechend aktualisiert wird, wenn z.B die Vertex-Koordinaten neu berechnet werden.
	
	\paragraph{View}
	Die \textit{View} stellt den UI Zustand des \textit{ViewModels} dar. Sie setzt sich aus einer Controller Klasse sowie einer deklarativen \gls{fxml} Datei zusammen. Die View hält eine Instanz des ViewModels und leitet die eingehenden Anfragen direkt an dieses weiter. Mit der Databinding-API wird eine bidirektionale Kommunikation zwischen \textit{View} und \textit{ViewModel} sichergestellt. 
	
	\paragraph{ViewModel}
	Das \textit{ViewModel} kennt die View nicht. Es hat somit keine Abhängigkeiten zu konkreten Anzeige-Elementen. Dies hat den grossen Vorteil, dass die gesamte UI Logik im \textit{ViewModel} gekapselt ist und somit sehr gut testbar ist. Das ViewModel enthält \gls{javafx} spezifische Properties, die für das bidirektionale Binding zwischen UI Komponenten und Code Behind nötig sind.
	
	\subsection{Business Layer}
	Im Business Layer liegt die eigentliche Logik. Er enthält keine \gls{javafx} Komponenten, weshalb das eingesetzte UI Framework ohne weiteres ausgewechselt werden kann. 
	
	\subsection{Access Layer}
	Der Access Layer enthält Klassen für den Zugriff auf den Socket Server, sowie das File System. Es Ist für das Parsen von eingehenden XML Files zuständig und für deren Umwandlung in Domainobjekte.

	\section{Refactoring Konzept} \label{sec:refactroing-conpet}
	Das Refactoring des GVS 1.0 soll organisiert durchgeführt werden. Dazu werden die notwendigen Schritte priorisiert aufgelistet.
		
	\subsection{Ablauf}\label{ssec:ablauf}
	\begin{enumerate}
		\item Der Presentation Layer wird ersetzt. Dabei wird \gls{swing} durch \gls{javafx} ersetzt. Mehr Details finden sich in der Migrations Liste (\ref{ssec:class-refactroing-list}) sowie im Klassendiagramm von GVS 2.0 (\ref{sec:class-diagram})
		\item Die GVS 1.0 Library wird um Generics erweitert. Dies betrifft die Java-, sowie die .NET Library.
		\item Eine klare Schichtenarchitektur (\ref{ssec:layer-architecture}) wird eingeführt. Besonders wichtig ist dabei, die Entfernung von \gls{tangle}s.
		\item Duplicated Code und weitere Code Smells sollen entfernt werden. Ein besonderes Augenmerk wird auf ein konsequentes Naming, das \gls{dry} Konzept sowie das ''Single Responsibility'' Konzept für Klassen und Methoden gelegt.
	\end{enumerate}

	\subsection{Migrations Liste}
	\label{ssec:class-refactroing-list}
	Die folgende Liste zeigt, welche Klassen aus GVS 1.0 übernommen werden und welche Klassen in welcher Art und Weise verändert oder neu erstellt werden.
	
	\includepdf[fitpaper]{assets/pdf/Migration_Replacements.pdf}
	
	\chapter{Realisierung}
		
	\begin{table}[h!]
	\centering
	\begin{tabularx}{\linewidth}{l l X l}
		\toprule 
		Datum & Version & Änderungen & Autor \\
		\midrule
		28.09.17 & 1.0 & Dokument erstellt, Logo beschrieben & mwieland \\
		06.12.17 & 1.1 & Besondere Herausforderungen beschrieben & mtrentini \\
		\bottomrule 
	\end{tabularx} 
	\caption{Versionshistory Realisierung} 
	\end{table}
	
	\section{Besondere Herausforderungen}
	In diesem Kapitel werden einige Features von GVS 2.0 genauer erläutert, welche sich als besondere Herausforderungen erwiesen haben.
	
	\subsection{Schnittpunkt von Edge und Vertex}
	\subsubsection{Problem}
	In einem ersten Stadium hat GVS 2.0 nur ungerichtete Kanten angezeigt. Somit konnten Edges sehr einfach als Linien dargestellt werden, die zwei Vertex Mittelpunkte verbinden. Im endgültigen Stadium zeigt das GVS 2.0 auch gerichtete Kanten an. Somit genügt der einfach Lösungsansatz aus Stadium eins nicht mehr, denn bei diesem Ansatz werden Pfeilspitzen durch die darüber liegenden Vertices verdeckt.
	
	Um das Problem zu lösen, braucht es ein Algorithmus, der die Schnittpunkte zwischen einer Kante und dem Rand eines Vertex findet. Damit kann ein Pfeil zwischen zwei Schnittpunkten statt zwei Vertex Mittelpunkten gezeichnet werden. Zu beachten ist zudem, dass sich diese Schnittpunkte ändern, wenn die betreffenden Vertices vom User ''gedragged'' werden.
	
	\subsubsection{Lösung}
	Die Lösung bietet ein Suchalgorithmus, der wie der \textit{Binary Search Algorithm} \cite{adbook} funktioniert. So wird ebenfalls mit zwei Endpunkten begonnen, welche in diesem Fall den Mittelpunkten des Start- und Endvertex der Kante entsprechen. Mittels Rekursion wird dann der Schnittpunkt gesucht. Beispielhaft ist der Ablauf mit den verschiedenen Iterationen in Abbildung \ref{fig:binarySearch} dargestellt. \\
	In einem ersten Schritt wird der Mittelpunkt zwischen den beiden Endpunkten bestimmt (in Abbildung  \ref{fig:binarySearch} grün respektive orange eingezeichnet). Dann wird getestet, ob sich der Mittelpunkt innerhalb oder ausserhalb des Vertex befindet, denn für jede Iteration wird ein Punkt innerhalb und ein Punkt ausserhalb des Vertex benötigt. \\
	Für die nächste Iteration wird der neu bestimmte Mittelpunkt plus einer der Endpunkte übergeben. In Abbildung  \ref{fig:binarySearch} zeigen Iterationen eins bis drei den Fall, dass der Mittelpunkt ausserhalb des Vertex zu liegen kommt. Ab Iteration vier wechselt das Szenario, da der Mittelpunkt innerhalb des Vertex zu liegen kommt. In Iteration sechs ist der Abstand zwischen den Endpunkten so klein, dass die Abbruch Bedingung der Rekursion zu tragen kommt und der gesuchte Schnittpunkt gefunden ist. \\
	
	
	\begin{figure}
		\centering
		\includegraphics[width=0.7\linewidth]{assets/images/binarySearch}
		\caption{Algorithmus zur Suche eines Schnittpunktes}
		\label{fig:binarySearch}
	\end{figure}
	
	Die spezifische Implementierung dieses Suchalgorithmus ist dem Listing \ref{code:binarySearch} zu entnehmen.
	
	\begin{lstlisting}[language=java, frame=single,caption={Algorithmus Schnittpunkt Suche}, label={code:binarySearch}]
		public Point2D findIntersectionPoint(Point2D outside, Point2D inside) {
			Point2D middle = outside.midpoint(inside);
		
			double deltaX = outside.getX() - inside.getX();
			double deltaY = outside.getY() - inside.getY();
		
			if (Math.hypot(deltaX, deltaY) < 1.) {
				return middle;
			} else {
				if (ellipse.contains(middle)) {
					return findIntersectionPoint(outside, middle);
				} else {
					return findIntersectionPoint(middle, inside);
				}
			}
		}
	\end{lstlisting}
	
	\section{UI Design}
	
	\subsection{Logo}
	Das Logo wurde von den Eigenschaften des Kraken \cite{kraken} inspiriert. Kraken sind bekannt dafür, dass sie viele Irrgarten-Probleme effizient lösen können. Dies ist eine Anspielung an die Algorithmen, die vom \gls{gvs} unterstützt werden. Ebenfalls wurden die Saugnäpfe des Kraken als Graph Nodes visualisiert und auf der Stirn ist ein binärer Baum zu erkennen. 
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.5\linewidth]{assets/images/logo}
		\caption[GVS Logo]{Graphs-Visualization-Service Logo}
		\label{fig:logo}
	\end{figure}
	
	\subsection{Screens}
	%TODO add screens
	
	\chapter{Ausblick}
	
	\section{UI Ausbau}
	
	\subsection{Threading Konzept}
	%TODO Multi or Single Threading?
	%TODO 4+1 Process View.
	
	\section{Lib Ausbau}
	
	\subsection{Algorithmen Library}
	
	\subsection{Annotations}
	
	
	
	\chapter{Projektplanung}
	
	
	\begin{table}[h!]
		\centering
		\begin{tabularx}{\linewidth}{l l X l}
			\toprule 
			Datum & Version & Änderungen & Autor \\
			\midrule
			25.09.17 & 1.0 & Dokument erstellt & mwieland, mtrentini \\
			28.09.17 & 1.1 & Risikomanagement hinzugefügt & mtrentini \\
			03.10.17 & 1.2 & IDE, Frameworks, Buildprozess, Qualitätsmanagement hinzugefügt, & mwieland \\
			05.10.17 & 1.3 & Meilensteine definiert & mtrentini \\
			\bottomrule 
		\end{tabularx} 
		\caption{Versionshistory Projektmanagement} 
	\end{table}
	
	\section{Meilensteine}
	\label{sec:milestones}
	
	\subsubsection{Meilenstein 1: Analyse}
	Analyse des Ist-Zustandes von GVS 1.0: Die Problemdomäne wird spezifiziert. Mehrere Diagramme zeigen die Schnittstelle zwischen dem Business Layer und dem Presentation Layer auf. Es ist ersichtlich, wie die einzelnen Komponenten miteinander kommunizieren bzw. wie die Daten von der Socket ans UI weiter gereicht werden.\\
	Die in der Aufgabenstellung (\ref{aufgabenstellung}) geforderten Requirements werden festgehalten.
	
	\subsubsection{Meilenstein 2: Entwurf}
	\label{milestone2}
	Entwurf des Soll-Zustand von GVS 2.0: Eine klassische 3-Schichten Architektur wird entworfen. Es wird spezifiziert, welche GVS 1.0 Komponenten durch welche GVS 2.0 Komponenten ersetzt werden. 
	
	\subsubsection{Meilenstein 3: Release 1}
	Der Presentation Layer ist vollständig gemäss Punkt 1 im Refactroing Konzept (\ref{sec:refactroing-conpet}) umgesetzt.
	
	\subsubsection{Meilenstein 4: Release 2}
	Die im Refactoring Konzept (\ref{sec:refactroing-conpet}) beschlossenen Änderungen sind umgesetzt. Das mit dem Enterprise Architekt erstellte Klassendiagramm ist mit dem Stand der GVS 2.0 Software synchron.
	
	\subsubsection{Meilenstein 5: Release 3}
	Alle im Meilenstein 2 definierten Requirements sind umgesetzt. Die GVS 2.0 Software ist für den Einsatz im Unterricht bereit.
	
	\begin{table}[h!]
		\centering
		\begin{tabular}{l l l l}
			\toprule 
			\# & Name & Artefakte & Datum \\
			\toprule 
			1 & Analyse & Anforderungsspezifikation & 11.10.17 \\
			& & Klassendiagramm 1.0 & \\
			& & Sequenzdiagramme & \\
			& &  Systemübersichts-Diagramm & \\
			\midrule
			2 & Entwurf  & Designspezifikation & 25.10.17\\
			& & Klassendiagramm 2.0 & \\
			& & Migrationstabelle & \\
			\midrule
			3 & Release 1 & GVS 2.0.1 & 22.11.2017 \\
			\midrule
			4 & Release 2 & GVS 2.0.2 & 06.12.2017 \\
			\midrule
			5 & Release 3 & GVS 2.0.3 & 22.12.2017 \\
			\bottomrule 
		\end{tabular} 
		\caption{Meilenstein Planung} 
	\end{table}
	
	\subsection{Artefact Overview}
	Im Artefact Overview sind sämtliche zu erbringende Arbeitsergebnisse mit ihren Fertigstellungsdaten aufgelistet. Wenn nötig sind verschiedene Versionen gekennzeichnet.
	\includepdf[landscape]{assets/pdf/artefact_overview.pdf}
	
	\section{Zeitplanung}
	
	Das Projekt wird im Rahmen der Studienarbeit durchgeführt. Insgesamt stehen 14 Wochen zur Verfügung in welchen jedes Teammitglied 240 Stunden leisten muss. Somit entstehen ca. 17 Stunden Arbeitsaufwand pro Woche und Teammitglied.
		
	\section{Projektverwaltung}
	
	Als Projektmanagement Software wird Jira \cite{jira} eingesetzt. In Jira werden alle Requirements als Issues erfasst und in den Product Backlog eingepflegt. Pro Iteration sollen jeweils so viele Issues eingeplant werden, wie unter Berücksichtigung von administrativen Aufgaben abgearbeitet werden können. Dabei spielt der Teamspeed eine grosse Rolle, welcher sich über die Projektdauer einpendeln soll. 

	
	\subsection{Iterationsplanung}
	Die Iterationsplanung orientiert sich grob am \gls{rup} und ist unterteilt in eine Inception-, Elaboration-, Construction- sowie eine Transition-Phase. Jede Phase besteht aus einer oder mehreren Iterationen, die jeweils 1 Wochen dauern und am Donnerstag enden. Die Sprints sind bewusst nur 1 Woche lang, um eventuell ändernden Anforderungen gerecht zu werden. Zudem bringen die Wochenmeetings (\ref{ssec:meeting}) jeweils neuen Input, welcher dann direkt in den nächsten Sprint einfliessen kann.\\
	Eine Iteration wird nach \gls{scrum} organisiert. Am Anfang des Sprints definiert das Projektteam die zu erledigenden Issues und schätzt deren Aufwand. (Siehe \ref{sec:estimations}) Jeweils am Ende eines Sprints wird die geleistete Arbeit reflektiert. Entsprechende Erkenntnisse und Verbesserungen werden fortlaufend in die Projektorganisation aufgenommen. 
		
	\subsection{Schätzungen}
	\label{sec:estimations}
	Issues werden auf Basis von Story Points geschätzt. Dieses Vorgehen hat sich mit SCRUM etabliert. Die Nutzung von Story Points führt dazu, dass nicht die individuell unterschiedliche Bearbeitungszeit, sondern die Komplexität einer User Story geschätzt wird. Dies vereinfacht  und homogenisiert die Schätzungen und hilft den Teamspeed zu bestimmen.\cite{storypoints, storypoints2}
	
	\subsection{Zeitauswertung}
	Für die Zeitauswertung wird das Jira Plugin Tempo \cite{jiratempo} verwendet. Dieses bietet umfassende Auswertungsmöglichkeiten, sowie Exports nach MS Excel. Die Reports zur geleisteten Zeit befinden sich im Anhang \ref{zeitauswertung}.
	
	\subsection{Meetings} \label{ssec:meeting}
	Über die gesamte Projektdauer findet jeweils am Mittwoch um 17:15 ein wöchentliches Standortmeeting statt. Die Beschlüsse aus den Meetings werden protokolliert und bis spätestens 24h später an alle Teilnehmer versendet. Allfälliges Feedback wird nachträglich eingepflegt und versioniert abgelegt.
	
	\subsection{Branch Konzept}
	Die Branch Struktur orientiert sich an Gitflow \cite{gitflow}. Pro Issue wird ein Feature Branch erstellt, der nach erfolgreichem Review in den Development Branch gemerged wird. Beim Erreichen eines Meilensteins (siehe \ref{sec:milestones}) wird der Entwicklungszweig in den Master Branch gemerged.
	
	\section{Entwicklungsumgebung}
	Als \gls{ide} wird Eclipse mit folgenden Plugins verwendet
	\begin{itemize}
		\item FindBugs \cite{findbugs} zur statischen Code Analyse
		\item Stan4J \cite{stan4j} zur Überprüfung von zyklischen Abhängigkeiten
		\item Checkstyle \cite{checkstyle} zur Überprüfung der Coding Richtlinien.
	\end{itemize}

	\section{Frameworks}
	
	\subsection{Gluon Ignite mit Google Guice}
	Gluon Ignite \cite{gluonignite} erweitert das verbreitete \gls{di}-Framework Guice \cite{guice} für den Einsatz in \gls{javafx} Applikationen. Mit Gluon Ignite lässt sich \gls{di} nicht nur im Business Layer, sondern auch für die \gls{fxml} Loader verwenden. \gls{di} verbessert die Testbarkeit und zentralisiert die Erzeugungslogik von Klassenobjekten.

	\section{Repositories}
	Die Artefakte werden in verschiedenen Repositories auf GitHub versioniert abgelegt. So gibt es für die Dokumentation, die Meetings-Protokolle und den Sourcecode jeweils ein eigenes Repository.

	\section{Continuous Integration}
	Die Software wird nach jedem Commit mit Travis CI \cite{travisci} gebuildet. Dies garantiert, dass sämtliche Qualitätsmassnahmen stets eingehalten werden. (Siehe \ref{sec:qualitymeasures})
	
	\subsection{Buildprozess}
	\label{sec:buildprocess}
	Zur Erstellung der Software Artefakte wird Gradle \cite{gradle} eingesetzt. Gradle verwaltet alle externen Software Abhängigkeiten. Zusätzlich wird die Software nur dann gebuilded, wenn alle Metriktools grünes Licht geben. Es resultiert ein ausführbares \gls{jar}.
		
	\section{Qualitätsmanagement}
	\label{sec:qualitymeasures}
	
	\subsection{Unit Tests}
	Zur Sicherung der Software Qualität sind gute Tests unerlässlich. Da jedoch ein grosser Teil des Business Layers von GVS 1.0 übernommen wird, ist es nicht realistisch, für sämtliche Klassen Unit Tests nachzureichen. Klassen die neu erstellt oder einem weitreichendem Refactroing unterzogen werden, sollen hinreichenden mit Tests abgedeckt sein. Der Schwerpunkt liegt dabei auf der Qualität und nicht auf einer möglichst hohen Testabdeckung.
	
	\subsection{Definition of Done} \label{ssec:dod}
	Source Code wird erst zum Review freigegeben, wenn folgende Kriterien erfüllt sind.
	\begin{itemize}
		\item Die \gls{ide} rsp. Build Tool zeigt keine Warnungen und Fehler
		\item Es gibt keinen auskommentierten Code
		\item Es existieren sinnvolle Unit und Integrationstests für das Feature
		\item Alle Metriken geben grünes Licht
		\item Das Issue wurde in Jira \cite{jira} zum Review vermerkt
	\end{itemize}
		
	\subsection{Review}
	Nach Abschluss eines Issues wird dieses an den Teampartner zum Review übergeben. Durch das Vier-Augen-Prinzip kann die Qualität des Produktes hoch gehalten werden. Zusätzlich haben beide Teampartner stets den selben Wissensstand.
	
	\subsection{Metriken} \label{ssec:metriken}
	Mit den Metriken kann während der Entwicklung geprüft werden, ob die Code Qualität den gesetzten Vorgaben (Siehe \ref{ssec:dod}) entspricht.
	
	\subsubsection{Code Style}
	Als Styleguide wird eine angepasste Version des Sun Styleguide verwendet \cite{suncheckstyle}. Damit dieser im Projekt durchgängig eingehalten wird, wird das Checkstyle Plugin \cite{checkstyle} in den Buildprozess integriert. (Siehe \ref{sec:buildprocess})	
	
	\subsubsection{Code Climate}
	%TODO Check technical debt
	Zur Überwachung des Technical Debt und der Testabdeckung wird die Github App Code Climate \cite{codeclimate} eingesetzt. Code Climate visualisiert die mittels Cobertura \cite{cobertura} erstellten \gls{xml} Testabdeckung Files.
	
	\subsection{Refactorings}
	Aufgrund der erkannten Mängel in der Analysephase (Siehe \ref{sec:erkenntnisse}) werden fortlaufend Refactorings des migrierten Codes durchgeführt.

	\section{Risikomanagement}
	Nachfolgend sind die wichtigsten Risiken für diese Arbeit aufgelistet. Gewichtet werden die Risiken nach Eintrittswahrscheinlichkeit und Schadenshöhe. \cite{risikomanagement}
	
	\begin{table}[h!]
		\centering
		\begin{tabular}{l c c}
			\toprule 
			\# & Eintrittswahrscheinlichkeit (E) & Schadensschwere (S) \\
			\toprule 
			1 & gering & leicht  \\
			2 & mittel & mittelschwer \\
			3 & hoch & schwer \\
			\bottomrule 
		\end{tabular} 
		\caption{Legende Risiken} 
	\end{table}
	\begin{landscape}		
		\subsection{Mögliche Risiken}
			\begin{table}[h!]
			\centering
			\begin{tabularx}{\linewidth}{l X l l X X}
				\toprule 
				\# & Beschreibung & E & S & Prävention & Massnahmen bei Eintritt \\
				\toprule 
				1 & Verlust von Daten auf Grund von technischen Störungen oder Diebstahl von persönlichen Notebooks & 2 & 1 & Backups (siehe \ref{sec:backup}) & Durch die Massnahmen muss höchstens ein Datenverlust von 8h aufgearbeitet werden. \\
				\midrule
				2 & Die Schnittstelle zwischen Business Logik und Presentation Layer ist weitaus weniger wohldefiniert als ursprünglich angenommen. Der nötige Zeitaufwand übersteigt die Schätzung um ein Vielfaches & 1 & 2 & Gute Recherche und Einarbeit in GVS 1.0, genügend lange Elaboration Phase & Rücksprache mit Betreuer. Überprüfen des Projektscopes und allenfalls Anpassung des Scopes. \\
				\midrule
				3 & Funktionalitäten von GVS 1.0, welche mit Swing umgesetzt wurden, werden durch JavaFX nicht oder unzureichend unterstützt & 1 & 2 & Einlesen in JavaFX, Funktionalitäten GVS 1.0 abklären & Alternative zur bestehenden Umsetzung finden \\
				\midrule
				4 & Eingesetzte Frameworks, Libraries und Cloud Services harmonieren nicht wie angenommen & 2 & 2 & Auf einen Software Stack setzen, der beliebt und weit verbreitet ist. Dies reduziert das Risiko, dass der gegenseitige Support fehlt. & Alternativen für inkompatible Services finden \\  
				\midrule 
				5 & Der geplante Funktionsumfang von GVS 2.0 übersteigt das Zeitbudget, dass im Rahmen der Studienarbeit zur Verfügung steht & 2 & 3 & Endprodukt in Teilkomponenten aufteilen. Pro Komponente den zeitlichen Aufwand bewerten. Klare Definition, welche Artefakte zwingend umgesetzt werden müssen. & Frühzeitige Rücksprache mit dem Betreuer, wenn sich abzeichnet, dass eine Komponente mehr Arbeit in Anspruch nimmt. \\  
				\bottomrule 
			\end{tabularx} 
			\caption{mögliche Risiken} 
		\end{table}
    \end{landscape}

	\subsection{Backups}
		\label{sec:backup}
		Zur Minimierung von allfälligen Datenverlusten wird wie folgt vorgegangen:
	
	\begin{enumerate}
		\item Täglich automatisiertes Backup aller Projektdaten im JIRA \cite{jira} (Zeiterfassung, erstellte Issues, Jira Konfiguration)
		\item Die Projektdokumentation sowie der Programmcode wird in den vier Github Repositories der Github Organisation \cite{github} versioniert abgelegt. Für die Projektmitglieder gilt der Grundsatz ''Commit early and often''.
		\item Weitere Artefakte werden auf Dropbox \cite{dropbox} abgelegt und dort automatisch gesichert und versioniert.
	\end{enumerate}
	
	
	\newpage
	
	\appendix
	\noappendicestocpagenum
	\addappheadtotoc
	\appendixpage
	
	% Glossary
	\printglossary
	\glsaddall
	
	% List of references
	\printbibliography[heading=bibintoc]
	
	{
		\hypersetup{linkcolor=black}
		\listoffigures
	}
	
	{
		\hypersetup{linkcolor=black}
		\listoftables
	}
	
	
	
	\chapter{Eigenständigkeitserklärung}
	Der/Die Verfasser/in erklärt hiermit, dass er/sie die vorliegende Arbeit selbständig, ohne fremde Hilfe und ohne Benutzung anderer als die angegebenen Hilfsmittel angefertigt hat. Die aus fremden Quellen (einschliesslich elektronischer Quellen) direkt oder indirekt übernommenen Gedanken sind ausnahmslos als solche kenntlich gemacht. Durch Copyright geschützte Materialien wurden in dieser Arbeit nicht in unerlaubter Weise genutzt. Die Arbeit ist in gleicher oder ähnlicher Form oder auszugsweise im Rahmen einer anderen Prüfung noch nicht vorgelegt worden.\\[2cm]
	\dotbox{Ort, Datum} \hfill \dotbox{Unterschrift des/der Verfassers/in}
	\hfill \\[2cm]
	\dotbox{Ort, Datum} \hfill \dotbox{Unterschrift des/der Verfassers/in}
	
	\chapter{Vereinbarung über Urheber- und Nutzungsrechte}
	
	%TODO add scan
	
	\chapter{Aufgabenstellung}
	\label{aufgabenstellung}
	Die folgenden Seiten enthalten die offizielle Aufgabenstellung dieser Studienarbeit.
	
    \includepdf[pages={1-}]{assets/Aufgabenstellung_GVS2.pdf}


	\chapter{Persönliche Berichte}
	\label{erfahrungsberichte}
	
	\chapter{Zeitauswertung}
	\label{zeitauswertung}
	
	\chapter{Testspezifikation}
	
	\chapter{Meeting Protokolle}
	
	
	
\end{document}

